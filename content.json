{"posts":[{"title":"差分数组和前缀和","text":"差分数组和前缀和的用法 基本结构前缀和（Prefix）对于数组${a_n}$，我们构造数组${S_n}$，使得其满足：$$S_i=a_1+a_2+…+a_i\\ \\ \\ \\ i\\in[1,n]$$那么，我们称${S_n}$为${a_n}$的前缀和数组。 差分（Difference）对于数组${a_n}$，我们构造数组${b_n}$，使得其满足：$$\\begin{equation}b_i=\\begin{cases}a_i-a_{i-1}&amp; \\text{ $ i \\in [2,n] $ } \\a_1&amp; \\text{ $ i=1 $ }\\end{cases}\\end{equation}$$那么，我们称${b_n}$为${a_n}$的差分数组。 需要注意，差分反映的是后一元素对前一元素的变化。 不难发现差分数组中的${a_n}$相当于前缀和数组中的${S_n}$，${b_n}$相当于前缀和数组中的${a_n}$，因此我们说这两个结构和其对应的一些运算是互逆的。 性质 对于数组${a_n}$和其前缀和数组${S_n}$，如果我们希望得到一个区间，如$[l,r]$上的数的和，我们可以这样做：$$S_{l-r}=S_r-S_{l-1}$$ 对于数组${a_n}$和其差分数组${b_n}$，如果我们对区间$[l,r]$上的所有元素同时加$c$，那么只需要对差分数组中的$b_l$和$b_{r+1}$分别加$c$和减$c$即可。注意：如果涉及到数组中最后一个数据的处理，则只需对最后一个数加$c$即可 用法 利用性质1，在求区间时只需要将前缀和数组中的两个对应元素相减即可。 利用性质2，在将区间内元素同时加或减同一值时只需对差分数组中的对应的两个元素操作即可。 例子前缀和 给出数组int a[6] = {0,5,7,2,4,9}，求区间[2,4]上的元素和。 构造前缀和数组：int b[6] = {0,5,12,14,18,27}。 区间[2,4]上的元素和为b[4] - b[1] = 13 通过笔算可以验证与直接对数组a求和得到的结果相同。 差分 给出数组int a[6] = {0,5,7,2,4,9}，在区间[2,4]上加3，区间[1,3]上减4，求修改后的数组a。 构造差分数组：int b[6] = {0,5,2,-5,2,5} 在区间[2,4]上加3后int b[6] = {0,5,5,-5,2,2} 在区间[1,3]上减4后int b[6] = {0,1,5,-1,2,2} 通过差分数组得到修改后的数组int a[6] = {0,1,6,5,7,9} 通过笔算可以验证与直接对数组a操作得到的结果相同。","link":"/2022/08/15/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"洛谷P1083 借教室","text":"二分+差分 题面 难度： 题目描述在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。 面对海量租借教室的信息，我们自然希望编程解决这个问题。 我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。 我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 输入格式第一行包含两个正整数 $n,m$，表示天数和订单的数量。 第二行包含 $n$ 个正整数，其中第 $i$ 个数为 $r_i$，表示第 $i$ 天可用于租借的教室数量。 接下来有 $m$ 行，每行包含三个正整数 $d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。 每行相邻的两个数之间均用一个空格隔开。天数与订单均用从 $1$ 开始的整数编号。 输出格式如果所有订单均可满足，则输出只有一行，包含一个整数 $0$。否则（订单无法完全满足） 输出两行，第一行输出一个负整数 $-1$，第二行输出需要修改订单的申请人编号。 样例样例输入123454 3 2 5 4 3 2 1 3 3 2 4 4 2 4 样例输出12-1 2 提示【输入输出样例说明】 第 $1 $份订单满足后，$4 $天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2 $天到第 $4$ 天每天提供$ 3 $个教室，而第 $3$ 天剩余的教室数为$ 2$，因此无法满足。分配停止，通知第$2$ 个申请人修改订单。 【数据范围】 对于10%的数据，有$1≤ n,m≤ 10$； 对于30%的数据，有$1≤ n,m≤1000$； 对于 70%的数据，有$1 ≤ n,m ≤ 10^5$； 对于 100%的数据，有$1 ≤ n,m ≤ 10^6,0 ≤ r_i,d_j≤ 10^9,1 ≤ s_j≤ t_j≤ n$。 题解涉及到多次同时对区间元素加减的操作就考虑差分，详见这篇博客。 这道题的二分切入点有点意思。判断一个订单是否能够满足，需要求某一天的总的预定数量，所以我一开始直接想到的就是对每一天进行二分，查找从哪一天开始出现问题，然后再对当天的订单回撤，直到撤到不会超出为止。但是仔细一想就会发现某一天的房间使用数量还会跟前几天的某些订单有关，因此这里比较巧妙其实就是我自己没想到的点就在于二分所有的订单，然后每次都分别算出到这个订单为止的所有天的房间预定情况，再进行二分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;int n, m;int *cap, *d, *s, *t;long long *rel;bool judge(int x){ rel = new long long[n + 2]; // 每天实际预定房间 for (int i = 0; i &lt;= n + 1; ++i) rel[i] = 0; for (int i = 1; i &lt;= x; ++i) { rel[s[i]] += d[i]; rel[t[i] + 1] -= d[i]; } long long today = 0; for (int i = 1; i &lt;= n; ++i) { today += rel[i]; if (today &gt; cap[i]) return false; } return true;}int main(){ cin &gt;&gt; n &gt;&gt; m; cap = new int[n + 1]; // 每天的可订房间数 d = new int[m + 1], s = new int[m + 1], t = new int[m + 1]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; cap[i]; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; d[i] &gt;&gt; s[i] &gt;&gt; t[i]; if (judge(m)) { cout &lt;&lt; 0; return 0; } int l = 1, r = m; while (l &lt;= r) { int mid = (l + r) / 2; if (judge(mid)) l = mid + 1; else r = mid - 1; } cout &lt;&lt; -1 &lt;&lt; endl &lt;&lt; r + 1; return 0;}","link":"/2022/08/15/%E6%B4%9B%E8%B0%B7P1083/"},{"title":"洛谷P1314 聪明的质检员","text":"二分+前缀和 题面 难度： 题目描述小T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $n$ 个矿石，从 $1$ 到 $n$ 逐一编号，每个矿石都有自己的重量 $w_i$ 以及价值 $v_i$ 。检验矿产的流程是： 1 、给定$ m$ 个区间 $[l_i,r_i]$； 2 、选出一个参数 $W$； 3 、对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$： $$y_i=\\sum\\limits_{j=l_i}^{r_i}[w_j \\ge W] \\times \\sum\\limits_{j=l_i}^{r_i}[w_j \\ge W]v_j$$ 其中 $j$ 为矿石编号。 这批矿产的检验结果 $y$ 为各个区间的检验值之和。即：$\\sum\\limits_{i=1}^m y_i$ 若这批矿产的检验结果与所给标准值 $s$ 相差太多，就需要再去检验另一批矿产。小T 不想费时间去检验另一批矿产，所以他想通过调整参数 $W$ 的值，让检验结果尽可能的靠近标准值 $s$，即使得 $|s-y|$ 最小。请你帮忙求出这个最小值。 输入格式第一行包含三个整数 $n,m,s$，分别表示矿石的个数、区间的个数和标准值。 接下来的 $n$ 行，每行两个整数，中间用空格隔开，第 $i+1$ 行表示 $i$ 号矿石的重量 $w_i$ 和价值 $v_i$。 接下来的 $m$ 行，表示区间，每行两个整数，中间用空格隔开，第 $i+n+1$ 行表示区间 $[l_i,r_i]$ 的两个端点 $l_i$ 和 $r_i$。注意：不同区间可能重合或相互重叠。 输出格式一个整数，表示所求的最小值。 样例样例输入1234567895 3 15 1 5 2 5 3 5 4 5 5 5 1 5 2 4 3 3 样例输出110 提示【输入输出样例说明】 当 $W$ 选 $4$ 的时候，三个区间上检验值分别为 $20,5 ,0$ ，这批矿产的检验结果为 $25$，此时与标准值 $S$ 相差最小为 $10$。 【数据范围】 对于 $10% $ 的数据，有 $1 ≤n ,m≤10$； 对于 $30% $的数据，有 $1 ≤n ,m≤500$ ； 对于 $50% $ 的数据，有 $ 1 ≤n ,m≤5,000$； 对于 $70%$ 的数据，有 $1 ≤n ,m≤10,000$ ； 对于 $100%$ 的数据，有 $ 1 ≤n ,m≤200,000$，$0 &lt; w_i,v_i≤10^6$，$0 &lt; s≤10^{12}$，$1 ≤l_i ≤r_i ≤n$ 。 题解首先：编号挺好 其次：这样的质检员能要？放到科研界妥妥的学术造假 又是一道二分解决最优解的问题。但是题目乍一看好像不满足单调性，因为差值与参数w的关系是一种类似二次函数的关系，是在大概中间某个值取到最值。但是检测结束后得到的检测结果y与参数w之间是正相关的。参数w设置的越小，能检测到的矿石越多，得到的结果就越大。因此这里我们需要在二分模板的基础上稍微改动一下：最终的答案不是在小于或者大于时更改，而是每一次都与当前最小值比较，并更新。 此外如果在计算检测结果y的过程中遍历的话有30%的会TLE。由于检测的都是区间，因此考虑前缀和，只不过前缀和的计算时机与一般题目不太相同。我们需要在每一次判断时根据设定的参数w计算。 下面是AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;using namespace std;int n, m;long long s;pair&lt;int, int&gt; *regions;pair&lt;int, int&gt; *stones;long long cal(int w){ // 求参数为w时对应的计数和价值的前缀和。 long long *c = new long long[n + 1]; long long *v = new long long[n + 1]; c[0] = 0, v[0] = 0; for (int i = 1; i &lt;= n; ++i) { c[i] = c[i - 1]; v[i] = v[i - 1]; if (stones[i].first &gt;= w) { ++c[i]; v[i] += stones[i].second; } } long long res = 0; for (int i = 0; i &lt; m; ++i) { res += (c[regions[i].second] - c[regions[i].first - 1]) * (v[regions[i].second] - v[regions[i].first - 1]); } return res;}int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; stones = new pair&lt;int, int&gt;[n + 1]; regions = new pair&lt;int, int&gt;[m]; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; stones[i].first &gt;&gt; stones[i].second; } for (int i = 0; i &lt; m; ++i) { cin &gt;&gt; regions[i].first &gt;&gt; regions[i].second; } int l = 0, r = 1e6; long long ans = 1e12; while (l &lt;= r) { int m = (l + r) / 2; long long c = cal(m); if (c &lt; s) // 检验结果大于标准值时需要减小参数w以放进更多的矿石 { r = m - 1; } else { l = m + 1; } // 由于差值与参数w不是线性相关的，因此每次都需要判断一下 ans = min(ans, abs(c - s)); } cout &lt;&lt; ans; return 0;}","link":"/2022/08/14/%E6%B4%9B%E8%B0%B7P1314/"},{"title":"排序算法","text":"今天刷洛谷快排板子题发现自己大二上学期数据结构里学的排序算法已经忘干净了，所以用这篇博客回忆一下其实是重新学一遍几个重要的排序算法。 首先列一下各排序的时间空间复杂度以及稳定性 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 快速排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$ 不稳定 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 桶排序 $O(n+k)$ $O(n+k)$ $O(n^2)$ $O(n+k)$ 稳定 基数排序 $O(n\\times k)$ $O(n\\times k)$ $O(n\\times k)$ $O(n+k)$ 稳定 冒泡排序太经典了，也很简单，就是左右比较然后交换，第i次排序能选出第i大的元素 12345678910111213void bubbleSort(int nums[], int size){ for (int i = size; i &gt; 0; --i) // 确定每一趟的右侧边界 { for (int j = 1; j &lt; i; ++j) { if (nums[j - 1] &gt; nums[j]) // 把大数放在后面 { swap(nums[j - 1], nums[j]); } } }} 选择排序每次遍历都去寻找第i大或者第i小的元素然后与第i个位置的元素交换 123456789101112131415void selectionSort(int nums[], int size){ for (int i = 0; i &lt; size; ++i) // 确定每一趟的左侧边界 { int index = i; // 初始化最小值下标 for (int j = i; j &lt; size; ++j) { if (nums[j] &lt; nums[index]) // 记录最小值下标 { index = j; } } swap(nums[i], nums[index]); // 将第i小元素放到第i个位置 }} 插入排序首先将第1个元素看作已经有序的序列，将后面的序列看作无序的序列，每次将一个无序序列里的元素插入到有序序列的合适的位置，如果相同就放在后面（保证稳定）。 1234567891011121314void insertionSort(int nums[], int size){ for (int i = 1; i &lt; size; ++i) // i之前的为有序部分 { int key = nums[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; key &lt; nums[j]) { nums[j + 1] = nums[j]; // 大于key的元素右移 --j; } nums[j + 1] = key; }} 归并排序递归地完成排序： 如果归并段长度为1，返回 将归并段从中间一分为二，分别处理成有序的段 将处理完的两个有序的归并段进行合并，使合并后的归并段依然有序 1234567891011121314151617181920212223242526272829303132333435void rMergeSort(int nums[], int left, int right){ if (left &gt;= right) // 归并段中只有一个元素 { return; } int mid = (left + right) / 2; rMergeSort(nums, left, mid); // 左右两段分别调用递归函数 rMergeSort(nums, mid + 1, right); int *newNums = new int[right - left + 1]; // 用于存储两个归并段合并的结果 int it = left, iu = mid + 1, i = 0; while (it != mid + 1 &amp;&amp; iu != right + 1) { newNums[i++] = (nums[it] &lt; nums[iu] ? nums[it++] : nums[iu++]); } while (it != mid + 1) { newNums[i++] = nums[it++]; } while (iu != right + 1) { newNums[i++] = nums[iu++]; } for (int i = 0; i &lt;= right - left; ++i) { nums[left + i] = newNums[i]; } return;}void mergeSort(int nums[], int size){ rMergeSort(nums, 0, size - 1);} 快速排序同样是递归地完成排序： 将序列中第一个元素作为标杆元素，然后设置两个指针分别从第二个元素向后找，最后一个元素向前找。 首先后指针开始前移（这个顺序很重要），找一个比标杆元素小的值然后停下。 随后前指针开始后移，找一个比标杆元素小的值然后停下。 两个元素交换位置 继续重复2-4直到两指针相遇，再与标杆元素交换。 以标杆元素为界，左右两段分别进行1-5这个过程。 1234567891011121314151617181920212223242526272829303132void rQuickSort(int nums[], int left, int right){ if (left &gt;= right) { return; } int it = left, iu = right; while (it &lt; iu) { while (it &lt; iu &amp;&amp; nums[iu] &gt;= nums[left]) { --iu; } while (it &lt; iu &amp;&amp; nums[it] &lt;= nums[left]) { ++it; } if (it &lt; iu) { swap(nums[it], nums[iu]); } } swap(nums[left], nums[it]); rQuickSort(nums, left, it - 1); rQuickSort(nums, it + 1, right);}void quickSort(int nums[], int size){ rQuickSort(nums, 0, size - 1);} 堆排序将需要排序的元素初始化为堆，然后每次从堆顶弹出元素。我太懒了，所以直接用STL实现了，至于堆是怎么实现的等我复习树的时候再说吧 1234567891011121314void heapSort(int nums[], int size){ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 0; i &lt; size; ++i) { q.push(nums[i]); } int i = 0; while (!q.empty()) { nums[i++] = q.top(); q.pop(); }} 计数排序&amp;桶排序&amp;基数排序这三种排序都使用了“桶的思想”，但在对桶的利用上有些差别 计数排序：每个桶只存放一个值，但记录这个值出现了几次 桶排序：每个桶只存放一个范围内的值 基数排序：按照值的每一位来存储 排序算法就到这里吧:-)","link":"/2022/08/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"洛谷P1309 瑞士轮","text":"核心算法：归并排序 题面 难度： 题目描述$2 \\times N$ 名编号为 $1\\sim 2N$ 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第$1$ 名和第$2$ 名、第 $3$ 名和第 $4$名、……、第$2K - 1 $名和第$ 2K$名、…… 、第$2N - 1 $名和第$2N$名，各进行一场比赛。每场比赛胜者得$1 $分，负者得 $0 $分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第$ Q$ 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。 输入格式第一行是三个正整数$N,R ,Q$,每两个数之间用一个空格隔开，表示有 $2 \\times N $名选手、$R$ 轮比赛，以及我们关心的名次 $Q$。 第二行是$2 \\times N$ 个非负整数$s_1, s_2, …, s_{2N}$，每两个数之间用一个空格隔开，其中$ s_i $表示编号为$i$ 的选手的初始分数。 第三行是$2 \\times N$ 个正整数$w_1 , w_2 , …, w_{2N}$，每两个数之间用一个空格隔开，其中 $w_i$ 表示编号为$i$ 的选手的实力值。 输出格式一个整数，即$R$ 轮比赛结束后，排名第$ Q$ 的选手的编号。 样例样例输入1232 4 2 7 6 6 7 10 5 20 15 样例输出11 提示【样例解释】 【数据范围】 对于$30% $的数据，$1 ≤ N ≤ 100$； 对于$50% $的数据，$1 ≤ N ≤ 10,000 $； 对于$100%$的数据，$1 ≤ N ≤ 100,000,1 ≤ R ≤ 50,1 ≤ Q ≤ 2N,0 ≤ s_1, s_2, …, s_{2N}≤10^8,1 ≤w_1, w_2 , …, w_{2N}≤ 10^8$。 看来自己对排序的认识还不够深刻，后面要对每种排序适合的场景搞明白才行。 这道题不能单纯的用C++ STL里的sort，否则只能得60分不要问我怎么知道的。 需要注意到一点：每轮比赛过后，所有赢者所构成的集合内部和所有输者所构成的集合内部都依然有序，所以每轮循环后将所有的赢者放进一个集合，输者放进一个集合。一轮比赛结束后再将两个集合合并就可以了。所以这道题其实是利用了归并排序的思想。 用快排暴力解决的复杂度为$O(n^2logn)$，而用归并解决的复杂度为$O(n^2)$。 最后贴一下AC代码 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b){ return a.first &gt; b.first || (a.first == b.first &amp;&amp; a.second &lt; b.second);}int main(){ int n, r, q; cin &gt;&gt; n &gt;&gt; r &gt;&gt; q; pair&lt;int, int&gt; *players = new pair&lt;int, int&gt;[2 * n]; int *power = new int[2 * n]; for (int i = 0; i &lt; 2 * n; ++i) { cin &gt;&gt; players[i].first; players[i].second = i; } for (int i = 0; i &lt; 2 * n; ++i) { cin &gt;&gt; power[i]; } sort(players, players + 2 * n, cmp); // 比赛开始前需要一次快排来得到所有比赛的参赛双方 pair&lt;int, int&gt; *winners = new pair&lt;int, int&gt;[n]; // 存储每一轮的赢者 pair&lt;int, int&gt; *losers = new pair&lt;int, int&gt;[n]; // 存储每一轮的输者 for (int i = 0; i &lt; r; ++i) { for (int j = 0; j &lt; n; ++j) { if (power[players[2 * j].second] &gt; power[players[2 * j + 1].second]) { ++players[2 * j].first; winners[j] = players[2 * j]; losers[j] = players[2 * j + 1]; } else { ++players[2 * j + 1].first; winners[j] = players[2 * j + 1]; losers[j] = players[2 * j]; } } merge(winners, winners + n, losers, losers + n, players, cmp); } cout &lt;&lt; players[q - 1].second + 1; return 0;}","link":"/2022/08/10/%E6%B4%9B%E8%B0%B7P1309/"},{"title":"洛谷P1902 刺杀大使","text":"二分+BFS/DFS 题面 难度： 题目描述某组织正在策划一起对某大使的刺杀行动。他们来到了使馆，准备完成此次刺杀，要进入使馆首先必须通过使馆前的防御迷阵。 迷阵由 $n\\times m$ 个相同的小房间组成，每个房间与相邻四个房间之间有门可通行。在第 $n$ 行的 $m$ 个房间里有 $m$ 个机关，这些机关必须全部打开才可以进入大使馆。而第 $1$ 行的 $m$ 个房间有 $m$ 扇向外打开的门，是迷阵的入口。除了第 $1$ 行和第 $n$ 行的房间外，每个房间都被使馆的安保人员安装了激光杀伤装置，将会对进入房间的人造成一定的伤害。第 $i$ 行第 $j$ 列 造成的伤害值为 $p_{i,j}$（第 $1$ 行和第 $n$ 行的 $p$ 值全部为 $0$）。 现在某组织打算以最小伤害代价进入迷阵，打开全部机关，显然，他们可以选 择任意多的人从任意的门进入，但必须到达第 $n$ 行的每个房间。一个士兵受到的伤害值为他到达某个机关的路径上所有房间的伤害值中的最大值，整个部队受到的伤害值为所有士兵的伤害值中的最大值。现在，这个恐怖组织掌握了迷阵的情况，他们需要提前知道怎么安排士兵的行进路线可以使得整个部队的伤害值最小。 输入格式第一行有两个整数 $n,m$，表示迷阵的大小。 接下来 $n$ 行，每行 $m$ 个数，第 $i$ 行第 $j$ 列的数表示 $p_{i,j}$。 输出格式输出一个数，表示最小伤害代价。 样例样例输入123454 20 0 3 5 2 4 0 0 样例输出13 提示 $50%$ 的数据，$n,m \\leq 100$； $100%$ 的数据，$n,m \\leq 1000$，$p_{i,j} \\leq 1000$。 题解抓住关键词：士兵受到的伤害值为经过的所有房间里伤害最大的，求最小伤害代价。 可以用二分枚举可能解，再以这个值为最大值，看看小于等于这个伤害值的房间所有是否连通。 这里以BFS为例给出AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int n, m;int **room;int dx[4] = {1, 0, 0, -1}; // 用于枚举每个房间联通的相邻的四个房间int dy[4] = {0, 1, -1, 0};bool judge(int x){ queue&lt;pair&lt;int, int&gt;&gt; q; int **vis = new int *[n]; for (int i = 0; i &lt; n; ++i) { vis[i] = new int[m]; for (int j = 0; j &lt; m; ++j) { vis[i][j] = 0; } } vis[0][0] = 1; q.push(pair&lt;int, int&gt;(0, 0)); while (!q.empty()) { int a = q.front().first; int b = q.front().second; q.pop(); for (int i = 0; i &lt; 4; ++i) { int _x = a + dx[i]; int _y = b + dy[i]; // 超出范围或已经访问过或房间伤害过大 if (_x &lt; 0 || _x &gt;= n || _y &lt; 0 || _y &gt;= m || vis[_x][_y] || room[_x][_y] &gt; x) continue; vis[_x][_y] = 1; if (_x == n - 1) // 检查是否已经达到第n行 return true; else q.push(pair&lt;int, int&gt;(_x, _y)); } } // 无法到达第n行房间 return false;}int main(){ cin &gt;&gt; n &gt;&gt; m; room = new int *[n]; // 存储左右边界，防止卡常 int l = 1e10, r = 0; for (int i = 0; i &lt; n; ++i) { room[i] = new int[m]; for (int j = 0; j &lt; m; ++j) { cin &gt;&gt; room[i][j]; l = min(l, room[i][j]); r = max(r, room[i][j]); } } int ans = 0; while (r &gt;= l) { int m = (l + r) / 2; if (judge(m)) { ans = m; r = m - 1; } else { l = m + 1; } } cout &lt;&lt; ans;}","link":"/2022/08/14/%E6%B4%9B%E8%B0%B7P1902/"},{"title":"洛谷P3952 时间复杂度","text":"第一篇题解！ 题面 难度： 题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下： 123F i x y循环体E 其中F i x y表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i +1$，一旦 $i$ 大于 $y$ 终止循环。 $x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 $100$。 E 表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母 $\\operatorname O$ 表示通常意义下 $Θ$ 的概念。 输入格式输入文件第一行一个正整数 $t$，表示有 $t$（$t \\le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y 和 E 即可计算时间复杂度。注意：循环结构允许嵌套。 接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，O(1) 表示常数复杂度，O(n^w) 表示复杂度为 $n^w$，其中 $w$ 是一个小于 $100$ 的正整数，输入保证复杂度只有 O(1) 和 O(n^w) 两种类型。 接下来 $L$ 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 $100$。 程序行若以E开头，则表示循环体结束。 输出格式输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出 Yes 或 No 或者 ERR，若程序实际复杂度与输入给出的复杂度一致则输出 Yes，不一致则输出 No，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出 ERR。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 样例样例输入1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 样例输出12345678YesYesERRYesNoYesYesERR 提示【输入输出样例解释 $1$】 第一个程序 $i$ 从 $1$ 到 $1$ 是常数复杂度。 第二个程序 $x$ 从 $1$ 到 $n$ 是 $n$ 的一次方的复杂度。 第三个程序有一个 F 开启循环却没有 E 结束，语法错误。 第四个程序二重循环，$n$ 的平方的复杂度。 第五个程序两个一重循环，$n$ 的一次方的复杂度。 第六个程序第一重循环正常，但第二重循环开始即终止（因为 $n$ 远大于 $100$，$100$ 大于 $4$）。 第七个程序第一重循环无法进入，故为常数复杂度。 第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 ERR。 【数据规模与约定】 对于 $30%$ 的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 F 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 E 开头的语句，$L \\le 10$，若 $x$、$y$ 均为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。 对于 $50%$ 的数据：不存在语法错误，$L \\le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$， 且只有 $y$ 有可能为 $n$。 对于 $70%$ 的数据：不存在语法错误，$L \\le 100$。 对于 $100%$ 的数据：$L \\le 100$。 注意点算是一道中等模拟题？反正比近几年CCF认证的T3不知道简单到哪里去了（bushi 其实整体不算复杂，但是有一些需要注意的点： 使用substr()时一定要算好从哪里开始！长度是多少！ 对于这种边输入边处理的题（或者叫解题方式）不能一发现可以break的地方就立即break，否则会导致后面的数据无法正常输入。 对于不能进入的循环，由于其内部嵌套循环也都无法进入，所有要在检测到后设置一个暂时的时间复杂度的门槛，一旦内部处理完后就取消掉这个门槛 这题测试集里竟然还有从n到n的循环其实是我太懒没往那里想 最后贴一下长达109行的AC代码（洛谷题解里竟然有40行的，就离谱） AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;int s2i(string s){ int ans = 0; for (int i = s.size() - 1; i &gt;= 0; --i) { ans += (pow(10, s.size() - 1 - i) * (s[i] - '0')); } return ans;}int main(){ int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { int l; string s; cin &gt;&gt; l &gt;&gt; s; int c; // 幂次 // 计算要求的复杂度 if (s == &quot;O(1)&quot;) c = 0; else c = s2i(s.substr(4, s.size() - 5)); stack&lt;int&gt; loop; // 存储进行到当前循环所需时间复杂度 vector&lt;string&gt; var; // 存储变量名 bool canStop = false; // 判断是否可以终止 int curMaxLoop = 1e9; // 用于处理外层循环无法进入时的情况 int maxO = 0; // 存储当前最大时间复杂度 for (int j = 0; j &lt; l; ++j) { string x, a, b; // 变量名,范围 cin &gt;&gt; x; if (x == &quot;E&quot;) { if (canStop) // 如果已经发现错误则后续只需吃掉该程序的输入，而不做后续处理 continue; if (var.empty()) // 循环终止符号多了 { canStop = true; continue; } var.pop_back(); // 没问题就弹出该循环所用的变量 if (curMaxLoop &gt;= var.size()) { loop.pop(); curMaxLoop = 1e9; } } else { cin &gt;&gt; x &gt;&gt; a &gt;&gt; b; if (canStop) continue; bool flag = false; // 用于判断是否有变量名冲突 for (auto &amp;it : var) { if (it == x) { flag = true; break; } } if (flag) { canStop = true; continue; } if (var.size() &lt;= curMaxLoop) { if (loop.empty()) loop.push(0); if (a == &quot;n&quot; &amp;&amp; b == &quot;n&quot; || a != &quot;n&quot; &amp;&amp; b != &quot;n&quot; &amp;&amp; s2i(a) &lt;= s2i(b)) // 时间复杂度次数不变 loop.push(loop.top()); else if (a == &quot;n&quot; || a != &quot;n&quot; &amp;&amp; b != &quot;n&quot; &amp;&amp; s2i(a) &gt; s2i(b)) // 该层循环无法进入 curMaxLoop = var.size(); else // 时间复杂度次数+1 loop.push(loop.top() + 1); } maxO = max(maxO, loop.top()); var.push_back(x); } } if (!var.empty()) // 终止符号少了 canStop = true; if (canStop) { cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; continue; } if (maxO == c) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; } return 0;}","link":"/2022/08/07/%E6%B4%9B%E8%B0%B7P3952/"},{"title":"洛谷P2678 跳石头","text":"一道二分查找题 题面 难度： 题目描述这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。 为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。 输入格式第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \\geq 1$ 且 $N \\geq M \\geq 0$。 接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i( 0 &lt; D_i &lt; L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。 输出格式一个整数，即最短跳跃距离的最大值。 样例样例输入12345625 5 2 2111417 21 样例输出14 提示输入输出样例 1 说明：将与起点距离为 $2$和 $14$ 的两个岩石移走后,最短的跳跃距离为 $4$(从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石,或者从距离 $21$ 的岩石跳到终点)。 另：对于 $20%$的数据,$0 ≤ M ≤ N ≤ 10$。 对于$50%$的数据,$0 ≤ M ≤ N ≤ 100$。 对于 $100%$的数据,$0 ≤ M ≤ N ≤ 50,000,1 ≤ L ≤ 1,000,000,000$。 题解为什么要用二分呢？因为二分很快。即使题目给出的范围有10亿，二分最多也只需要大约30次就能算完，可以算是常数级别的时间复杂度，远超一般的算法。 为什么能用二分呢？首先根据题意可以很快得到两个信息：一个是解有范围，二是解可以枚举（是整数）。然后我们就要看是否满足单调性，也就是说如果有一个$x_0=a$时不可行，那么对于所有$x\\geq x_0$或者$x\\leq x_0$都不可行。 比如我们给定一个解$x_0$，也就是一步最少跳$x_0$。然后开始模拟跳石头：如果下一个石头的距离大于这个值那么符合题意，这个石头不用撤；如果下一个石头的距离小于这个值，那么不符合这个解，就要把这个石头撤掉。然后，我们数一数在满足这个解的条件下撤掉的石头是否满足要求：如果大于说明这个值大了，比这个值大的都不可能满足题意，如果小于等于则说明可行，可以试试更大的值，也就是更优解。 下面贴一下AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;int l, n, m;int *stones;// 判断这个解是否满足题意bool judge(int x){ int tot = 0; int i = 1; int now = 0; while (i &lt;= n + 1) { if (stones[i] - stones[now] &lt; x) // 两石头的间隔小了，需要撤石头 tot++; else // 满足间隔就跳 now = i; ++i; } return tot &lt;= m;}int main(){ cin &gt;&gt; l &gt;&gt; n &gt;&gt; m; stones = new int[n + 2]; stones[0] = 0; // 起点 for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; stones[i]; } stones[n + 1] = l; // 终点 int b = 1, e = l; // 设置左右边界 int ans = 0; while (b &lt;= e) { int m = (b + e) / 2; if (judge(m)) // 如果满足题意，记录下当前答案，左端点右移看看有没有更优解 { ans = m; b = m + 1; } else // 不满足题意，右端点左移排除错误区间 { e = m - 1; } } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 一点问题在判断解是否可行的时候，有一个小问题需要额外讨论一下，就是代码中while (i &lt;= n + 1)中这个临界值究竟应该是n还是n+1，也即究竟要不要判断倒数第一个石头和终点之间的距离。虽然洛谷上两种代码都能AC，但两者真的都对吗？请看我下面给出的数据： 12348 3 1247 废话不多说先跑一遍： 终止条件为i &lt;= n + 1的代码跑出来的结果： 12 终止条件为i &lt;= n的代码跑出来的结果： 13 竟然不一样了！ 如果我们自己手算的话就能发现答案显然是2。后者错的原因就是它没有考虑到最后一个石头和终点之间的距离，导致最终结果撤掉了错误的石头（从结果来看是撤掉了第一个）。虽然输出的答案是3，但这种操作所对应的实际结果应该为1。 发现这个问题后我就到洛谷的题解区浏览是否有人和我有一样的发现，结果看到了几篇题解甚至都是错误的！我于是又翻看讨论区，发现有一些同学也看出了这个问题，并附上了自己的数据，只不过到本篇文章写完时（2022年8月13日15时）还没有看到这道题的加强数据。希望这篇题解能够抛砖引玉，让后来的同学能不轻易地完全相信题解，养成自己独立思考、发现问题、解决问题的能力。","link":"/2022/08/13/%E6%B4%9B%E8%B0%B7P2678/"},{"title":"洛谷P1908 逆序对","text":"又是利用了归并排序 题面 难度： 题目描述猫猫 TOM 和小老鼠 JERRY 最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。 最近，TOM 老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中 $a_i&gt;a_j$ 且 $i&lt;j$ 的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。注意序列中可能有重复数字。 输入格式第一行，一个数 $n$，表示序列中有 $n$个数。 第二行 $n$ 个数，表示给定的序列。序列中每个数字不超过 $10^9$。 输出格式输出序列中逆序对的数目。 样例样例输入1265 4 2 6 3 1 样例输出111 提示对于 $25%$ 的数据，$n \\leq 2500$ 对于 $50%$ 的数据，$n \\leq 4 \\times 10^4$。 对于所有数据，$n \\leq 5 \\times 10^5$ 解法朴素解法遍历所有的情况，共$\\frac{n(n-1)}{2}$种，时间复杂度$O(n^2)$，只能过$25%$的点。 主要代码 123456789101112131415int countInversion(int nums[], int size){ int ans = 0; for (int i = 0; i &lt; size; ++i) { for (int j = i + 1; j &lt; size; ++j) { if (nums[i] &gt; nums[j]) { ++ans; } } } return ans;} 冒泡排序实现冒泡排序，但是在每一次发生交换时记录一次。这种做法的正确性在于交换相邻的逆序对不会影响其他的逆序对的计数。其时间复杂度与朴素解法相同，但由于交换元素会消耗更多的时间，因此在一般情况下实际上比朴素解法更慢。 改进后的冒泡算法，即发现序列有序后停止算法会在序列基本有序的情况下优化时间复杂度。 插入排序序列中每一个元素都与其前序列中比自己大的数构成逆序对。因此插入排序中每一次比较都代表一个逆序对。由于每次比较都只找比自己大的元素，因此时间性能由于前两者，但时间复杂度仍然为$O(n^2)$。 代码： 1234567891011121314151617int countInversion(int nums[], int size){ int ans = 0; for (int i = 1; i &lt; size; ++i) { int key = nums[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt; key) { nums[j + 1] = nums[j]; ++ans; --j; } nums[j + 1] = key; } return ans;} 归并排序与冒泡排序的想法类似，一个归并段内的元素顺序的变换不会影响到序列其他部分的逆序对的数量。 在要进行归并的两个归并段中，后一个段第一个待归并元素在归并时，一定可以与前一个归并段的所有元素组成逆序对。因此只需要在当后半归并段待排序元素小于前半段待排序元素时，在结果中加上前半归并段未排序元素的数量就能得到结果。 特别要注意的是，判断指针移动的条件一定是前大于等于后，否则就会出现漏数的情况。 代码： 123456789101112131415161718192021222324252627282930313233int rCountInversion(int nums[], int left, int right){ if (left &gt;= right) return 0; int count = 0; int mid = (left + right) / 2; count += rCountInversion(nums, left, mid); count += rCountInversion(nums, mid + 1, right); int *newNums = new int[right - left + 1]; int it = left, iu = mid + 1, i = 0; while (it &lt;= mid &amp;&amp; iu &lt;= right) { if (nums[it] &gt; nums[iu]) { count += (mid - it + 1); } newNums[i++] = (nums[it] &lt;= nums[iu] ? nums[it++] : nums[iu++]); } while (it &lt;= mid) { newNums[i++] = nums[it++]; } while (iu &lt;= right) { newNums[i++] = nums[iu++]; } for (int i = 0; i &lt;= right - left; ++i) { nums[left + i] = newNums[i]; } return count;}","link":"/2022/08/12/%E6%B4%9B%E8%B0%B7P1908/"},{"title":"洛谷P4343 自动刷题机","text":"最后一篇二分 题面 难度： 题目描述自动刷题机刷题的方式非常简单：首先会瞬间得出题目的正确做法，然后开始写程序。每秒，自动刷题机的代码生成模块会有两种可能的结果： 1.写了 $x$ 行代码2.心情不好，删掉了之前写的 $y$ 行代码。（如果 $y$ 大于当前代码长度则相当于全部删除。） 对于一个 OJ，存在某个固定的正整数长度 $n$，一旦自动刷题机在某秒结束时积累了大于等于 $n$ 行的代码，它就会自动提交并 AC 此题，然后新建一个文件（即弃置之前的所有代码）并开始写下一题。SHTSC 在某个 OJ 上跑了一天的自动刷题机，得到了很多条关于写代码的日志信息。他突然发现自己没有记录这个 OJ 的 $n$ 究竟是多少。所幸他通过自己在 OJ 上的 Rank 知道了自动刷题机一共切了 $k$ 道题，希望你计算 $n$ 可能的最小值和最大值。 输入格式第一行两个整数 $l , k$，表示刷题机的日志一共有 $l$ 行，一共了切了 $k$ 题。 接下来 $l$ 行，每行一个整数 $x_i$，依次表示每条日志。若 $x_i \\geq 0$，则表示写了 $x_i$ 行代码，若 $x_i \\lt 0$，则表示删除了 $-x_i$ 行代码。 输出格式输出一行两个整数，分别表示 $n$ 可能的最小值和最大值。如果这样的 $n$ 不存在，请输出一行一个整数 $-1$。 样例样例输入123454 225-39 样例输出13 7 提示数据规模与约定 对于 $20%$ 的数据，保证 $l \\le 10$； 对于 $40%$ 的数据，保证 $l \\le 100$ ； 对于 $60%$ 的数据，保证$l \\le 2 \\times 10^3$； 对于 $100%$ 的数据，保证 $1 \\leq l \\le 10^5$，$-10^9 \\le x_i \\le 10^9$。 题解我也想变成一个自动刷题机！！！二分看似很简单，但其实变化还是挺多的，不知不觉竟然把提单里面除了第一道题的题解都写了一遍其实是我太菜了。这道题很明显能看出来用二分，但是与之前几道不同，这道题需要求最大值和最小值，也就是说在给出的n满足AC题目数的同时，需要找到最大的或最小的。 处理的办法就是在等于的情况下做文章。求最小值时，如果求出AC题目数量等于给出的数量，那么我们可以在更新结果的同时，缩短右边界来“试探”更小值。类似的，在求最大值时，如果求出的AC题目数量等于给出的数量，那么我们同样可以通过缩短左边界来“试探”更大值。最后，由于可能出现没有结果的情况，因此我们可以将存储答案的变量初始化为-1，这样如果没有找到合适的解就可以直接输出-1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#define INF 1e18using namespace std;int l, k;int *line;int cal(long long x){ int i = 0; int thek = 0; while (i != l) { long long n = 0; while (i != l &amp;&amp; n &lt; x) { n += line[i++]; if (n &lt; 0) { n = 0; } } if (n &gt;= x) { ++thek; } } return thek;}int main(){ ios::sync_with_stdio(false); cin &gt;&gt; l &gt;&gt; k; line = new int[l]; for (int i = 0; i &lt; l; ++i) { cin &gt;&gt; line[i]; } long long left = 1, right = INF, min = -1, max = -1; while (left &lt;= right) { long long m = (left + right) / 2; if (cal(m) &gt; k) { left = m + 1; } else // 当前解求出的K题数小了,说明m大了.相等的时候也要继续求更小值 { right = m - 1; if (cal(m) == k) { min = m; } } } left = 1, right = INF; while (left &lt;= right) { long long m = (left + right) / 2; if (cal(m) &lt; k) { right = m - 1; } else // 当前解求出的K题数大了,说明m小了.相等的时候也要继续求更大值 { left = m + 1; if (cal(m) == k) { max = m; } } } if (min == -1) { cout &lt;&lt; min; } else { cout &lt;&lt; min &lt;&lt; &quot; &quot; &lt;&lt; max; } return 0;}","link":"/2022/08/16/%E6%B4%9B%E8%B0%B7P4343/"},{"title":"洛谷刷题の目录","text":"从今天昨天开始刷洛谷的能力全面综合提升题单，把比较复杂或者有难度的题目记录下来。 这个就作为目录吧 由于本人没有ACM经验，对洛谷题目难度没有感觉，所以将题目难度分为以下七个等级，分别对应洛谷题目难度的七个等级 ——入门 ——普及- ——普及/提高- ——普及+/提高 ——提高+/省选- ——省选/NOI- ——NOI/NOI+/CTSC Part2 基础算法2.1 模拟这类问题通常流程长、情况多且杂。比较考验写代码时的耐心和细心，而且通常对处理复杂的字符串有一定要求。 P3952 时间复杂度 2.2 排序排序不仅仅是将数据排好顺序。其中不同排序方法的适用情况和对其基本思想的利用也很重要。 P1309 瑞士轮 P1908 逆序对 2.3 二分判断可以使用二分有以下几个条件 题目要求是寻找最优解 最优解有一定的范围 所求解可以枚举，比如为整数或给出精度 满足单调性，即通过判断某个值x不合适可以推出所有x’&lt;x或x’&gt;x都不合适 此外这种题一般使用其他方法正面攻破难度极大或会超时。 P2678 跳石头 P1902 刺杀大使 P1314 聪明的质监员 P1083 借教室 P4343 自动刷题机 2.4 分治2.5 贪心2.6 构造2.7 高精度2.8 差分","link":"/2022/08/06/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E7%9B%AE%E5%BD%95/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"洛谷刷题","slug":"洛谷刷题","link":"/categories/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[]}