{"posts":[{"title":"排序算法","text":"今天刷洛谷快排板子题发现自己大二上学期数据结构里学的排序算法已经忘干净了，所以用这篇博客回忆一下其实是重新学一遍几个重要的排序算法。 首先列一下各排序的时间空间复杂度以及稳定性 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 快速排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$ 不稳定 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 桶排序 $O(n+k)$ $O(n+k)$ $O(n^2)$ $O(n+k)$ 稳定 基数排序 $O(n\\times k)$ $O(n\\times k)$ $O(n\\times k)$ $O(n+k)$ 稳定 冒泡排序太经典了，也很简单，就是左右比较然后交换，第i次排序能选出第i大的元素 12345678910111213void bubbleSort(int nums[], int size){ for (int i = size; i &gt; 0; --i) // 确定每一趟的右侧边界 { for (int j = 1; j &lt; i; ++j) { if (nums[j - 1] &gt; nums[j]) // 把大数放在后面 { swap(nums[j - 1], nums[j]); } } }} 选择排序每次遍历都去寻找第i大或者第i小的元素然后与第i个位置的元素交换 123456789101112131415void selectionSort(int nums[], int size){ for (int i = 0; i &lt; size; ++i) // 确定每一趟的左侧边界 { int index = i; // 初始化最小值下标 for (int j = i; j &lt; size; ++j) { if (nums[j] &lt; nums[index]) // 记录最小值下标 { index = j; } } swap(nums[i], nums[index]); // 将第i小元素放到第i个位置 }} 插入排序首先将第1个元素看作已经有序的序列，将后面的序列看作无序的序列，每次将一个无序序列里的元素插入到有序序列的合适的位置，如果相同就放在后面（保证稳定）。 1234567891011121314void insertionSort(int nums[], int size){ for (int i = 1; i &lt; size; ++i) // i之前的为有序部分 { int key = nums[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; key &lt; nums[j]) { nums[j + 1] = nums[j]; // 大于key的元素右移 --j; } nums[j + 1] = key; }} 归并排序递归地完成排序： 如果归并段长度为1，返回 将归并段从中间一分为二，分别处理成有序的段 将处理完的两个有序的归并段进行合并，使合并后的归并段依然有序 1234567891011121314151617181920212223242526272829303132333435void rMergeSort(int nums[], int left, int right){ if (left &gt;= right) // 归并段中只有一个元素 { return; } int mid = (left + right) / 2; rMergeSort(nums, left, mid); // 左右两段分别调用递归函数 rMergeSort(nums, mid + 1, right); int *newNums = new int[right - left + 1]; // 用于存储两个归并段合并的结果 int it = left, iu = mid + 1, i = 0; while (it != mid + 1 &amp;&amp; iu != right + 1) { newNums[i++] = (nums[it] &lt; nums[iu] ? nums[it++] : nums[iu++]); } while (it != mid + 1) { newNums[i++] = nums[it++]; } while (iu != right + 1) { newNums[i++] = nums[iu++]; } for (int i = 0; i &lt;= right - left; ++i) { nums[left + i] = newNums[i]; } return;}void mergeSort(int nums[], int size){ rMergeSort(nums, 0, size - 1);} 快速排序同样是递归地完成排序： 将序列中第一个元素作为标杆元素，然后设置两个指针分别从第二个元素向后找，最后一个元素向前找。 首先后指针开始前移（这个顺序很重要），找一个比标杆元素小的值然后停下。 随后前指针开始后移，找一个比标杆元素小的值然后停下。 两个元素交换位置 继续重复2-4直到两指针相遇，再与标杆元素交换。 以标杆元素为界，左右两段分别进行1-5这个过程。 1234567891011121314151617181920212223242526272829303132void rQuickSort(int nums[], int left, int right){ if (left &gt;= right) { return; } int it = left, iu = right; while (it &lt; iu) { while (it &lt; iu &amp;&amp; nums[iu] &gt;= nums[left]) { --iu; } while (it &lt; iu &amp;&amp; nums[it] &lt;= nums[left]) { ++it; } if (it &lt; iu) { swap(nums[it], nums[iu]); } } swap(nums[left], nums[it]); rQuickSort(nums, left, it - 1); rQuickSort(nums, it + 1, right);}void quickSort(int nums[], int size){ rQuickSort(nums, 0, size - 1);} 堆排序将需要排序的元素初始化为堆，然后每次从堆顶弹出元素。我太懒了，所以直接用STL实现了，至于堆是怎么实现的等我复习树的时候再说吧 1234567891011121314void heapSort(int nums[], int size){ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 0; i &lt; size; ++i) { q.push(nums[i]); } int i = 0; while (!q.empty()) { nums[i++] = q.top(); q.pop(); }} 计数排序&amp;桶排序&amp;基数排序这三种排序都使用了“桶的思想”，但在对桶的利用上有些差别 计数排序：每个桶只存放一个值，但记录这个值出现了几次 桶排序：每个桶只存放一个范围内的值 基数排序：按照值的每一位来存储 排序算法就到这里吧:-)","link":"/2022/08/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"洛谷刷题の目录","text":"从今天昨天开始刷洛谷的能力全面综合提升题单，把比较复杂或者有难度的题目记录下来。 这个就作为目录吧 Part2 基础算法2.1 模拟P3952 时间复杂度 2.2 排序P1309 瑞士轮 P1908 逆序对 2.3 二分2.4 分治2.5 贪心2.6 构造2.7 高精度2.8 差分","link":"/2022/08/06/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E7%9B%AE%E5%BD%95/"},{"title":"洛谷P1309 瑞士轮","text":"核心算法：归并排序 难度：普及/提高- 题面 题目描述$2 \\times N$ 名编号为 $1\\sim 2N$ 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第$1$ 名和第$2$ 名、第 $3$ 名和第 $4$名、……、第$2K - 1 $名和第$ 2K$名、…… 、第$2N - 1 $名和第$2N$名，各进行一场比赛。每场比赛胜者得$1 $分，负者得 $0 $分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第$ Q$ 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。 输入格式第一行是三个正整数$N,R ,Q$,每两个数之间用一个空格隔开，表示有 $2 \\times N $名选手、$R$ 轮比赛，以及我们关心的名次 $Q$。 第二行是$2 \\times N$ 个非负整数$s_1, s_2, …, s_{2N}$，每两个数之间用一个空格隔开，其中$ s_i $表示编号为$i$ 的选手的初始分数。 第三行是$2 \\times N$ 个正整数$w_1 , w_2 , …, w_{2N}$，每两个数之间用一个空格隔开，其中 $w_i$ 表示编号为$i$ 的选手的实力值。 输出格式一个整数，即$R$ 轮比赛结束后，排名第$ Q$ 的选手的编号。 样例样例输入123&gt;2 4 2 7 6 6 7 &gt;10 5 20 15 样例输出11 提示【样例解释】 【数据范围】 对于$30% $的数据，$1 ≤ N ≤ 100$； 对于$50% $的数据，$1 ≤ N ≤ 10,000 $； 对于$100%$的数据，$1 ≤ N ≤ 100,000,1 ≤ R ≤ 50,1 ≤ Q ≤ 2N,0 ≤ s_1, s_2, …, s_{2N}≤10^8,1 ≤w_1, w_2 , …, w_{2N}≤ 10^8$。 看来自己对排序的认识还不够深刻，后面要对每种排序适合的场景搞明白才行。 这道题不能单纯的用C++ STL里的sort，否则只能得60分不要问我怎么知道的。 需要注意到一点：每轮比赛过后，所有赢者所构成的集合内部和所有输者所构成的集合内部都依然有序，所以每轮循环后将所有的赢者放进一个集合，输者放进一个集合。一轮比赛结束后再将两个集合合并就可以了。所以这道题其实是利用了归并排序的思想。 用快排暴力解决的复杂度为$O(n^2logn)$，而用归并解决的复杂度为$O(n^2)$。 最后贴一下AC代码 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b){ return a.first &gt; b.first || (a.first == b.first &amp;&amp; a.second &lt; b.second);}int main(){ int n, r, q; cin &gt;&gt; n &gt;&gt; r &gt;&gt; q; pair&lt;int, int&gt; *players = new pair&lt;int, int&gt;[2 * n]; int *power = new int[2 * n]; for (int i = 0; i &lt; 2 * n; ++i) { cin &gt;&gt; players[i].first; players[i].second = i; } for (int i = 0; i &lt; 2 * n; ++i) { cin &gt;&gt; power[i]; } sort(players, players + 2 * n, cmp); // 比赛开始前需要一次快排来得到所有比赛的参赛双方 pair&lt;int, int&gt; *winners = new pair&lt;int, int&gt;[n]; // 存储每一轮的赢者 pair&lt;int, int&gt; *losers = new pair&lt;int, int&gt;[n]; // 存储每一轮的输者 for (int i = 0; i &lt; r; ++i) { for (int j = 0; j &lt; n; ++j) { if (power[players[2 * j].second] &gt; power[players[2 * j + 1].second]) { ++players[2 * j].first; winners[j] = players[2 * j]; losers[j] = players[2 * j + 1]; } else { ++players[2 * j + 1].first; winners[j] = players[2 * j + 1]; losers[j] = players[2 * j]; } } merge(winners, winners + n, losers, losers + n, players, cmp); } cout &lt;&lt; players[q - 1].second + 1; return 0;}","link":"/2022/08/10/%E6%B4%9B%E8%B0%B7P1309/"},{"title":"洛谷P3952 时间复杂度","text":"第一篇题解！ 难度：普及+/提高 题面 题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下： 123F i x y&gt;循环体&gt;E 其中F i x y表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i +1$，一旦 $i$ 大于 $y$ 终止循环。 $x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 $100$。 E 表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母 $\\operatorname O$ 表示通常意义下 $Θ$ 的概念。 输入格式输入文件第一行一个正整数 $t$，表示有 $t$（$t \\le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y 和 E 即可计算时间复杂度。注意：循环结构允许嵌套。 接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，O(1) 表示常数复杂度，O(n^w) 表示复杂度为 $n^w$，其中 $w$ 是一个小于 $100$ 的正整数，输入保证复杂度只有 O(1) 和 O(n^w) 两种类型。 接下来 $L$ 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 $100$。 程序行若以E开头，则表示循环体结束。 输出格式输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出 Yes 或 No 或者 ERR，若程序实际复杂度与输入给出的复杂度一致则输出 Yes，不一致则输出 No，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出 ERR。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 样例样例输入12345678910111213141516171819202122232425262728293031323334&gt;82 O(1)&gt;F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 样例输出12345678&gt;YesYes&gt;ERRYesNoYesYesERR 提示【输入输出样例解释 $1$】 第一个程序 $i$ 从 $1$ 到 $1$ 是常数复杂度。 第二个程序 $x$ 从 $1$ 到 $n$ 是 $n$ 的一次方的复杂度。 第三个程序有一个 F 开启循环却没有 E 结束，语法错误。 第四个程序二重循环，$n$ 的平方的复杂度。 第五个程序两个一重循环，$n$ 的一次方的复杂度。 第六个程序第一重循环正常，但第二重循环开始即终止（因为 $n$ 远大于 $100$，$100$ 大于 $4$）。 第七个程序第一重循环无法进入，故为常数复杂度。 第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 ERR。 【数据规模与约定】 对于 $30%$ 的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 F 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 E 开头的语句，$L \\le 10$，若 $x$、$y$ 均为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。 对于 $50%$ 的数据：不存在语法错误，$L \\le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$， 且只有 $y$ 有可能为 $n$。 对于 $70%$ 的数据：不存在语法错误，$L \\le 100$。 对于 $100%$ 的数据：$L \\le 100$。 注意点算是一道中等模拟题？反正比近几年CCF认证的T3不知道简单到哪里去了（bushi 其实整体不算复杂，但是有一些需要注意的点： 使用substr()时一定要算好从哪里开始！长度是多少！ 对于这种边输入边处理的题（或者叫解题方式）不能一发现可以break的地方就立即break，否则会导致后面的数据无法正常输入。 对于不能进入的循环，由于其内部嵌套循环也都无法进入，所有要在检测到后设置一个暂时的时间复杂度的门槛，一旦内部处理完后就取消掉这个门槛 这题测试集里竟然还有从n到n的循环其实是我太懒没往那里想 最后贴一下长达109行的AC代码（洛谷题解里竟然有40行的，就离谱） AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;int s2i(string s){ int ans = 0; for (int i = s.size() - 1; i &gt;= 0; --i) { ans += (pow(10, s.size() - 1 - i) * (s[i] - '0')); } return ans;}int main(){ int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { int l; string s; cin &gt;&gt; l &gt;&gt; s; int c; // 幂次 // 计算要求的复杂度 if (s == &quot;O(1)&quot;) c = 0; else c = s2i(s.substr(4, s.size() - 5)); stack&lt;int&gt; loop; // 存储进行到当前循环所需时间复杂度 vector&lt;string&gt; var; // 存储变量名 bool canStop = false; // 判断是否可以终止 int curMaxLoop = 1e9; // 用于处理外层循环无法进入时的情况 int maxO = 0; // 存储当前最大时间复杂度 for (int j = 0; j &lt; l; ++j) { string x, a, b; // 变量名,范围 cin &gt;&gt; x; if (x == &quot;E&quot;) { if (canStop) // 如果已经发现错误则后续只需吃掉该程序的输入，而不做后续处理 continue; if (var.empty()) // 循环终止符号多了 { canStop = true; continue; } var.pop_back(); // 没问题就弹出该循环所用的变量 if (curMaxLoop &gt;= var.size()) { loop.pop(); curMaxLoop = 1e9; } } else { cin &gt;&gt; x &gt;&gt; a &gt;&gt; b; if (canStop) continue; bool flag = false; // 用于判断是否有变量名冲突 for (auto &amp;it : var) { if (it == x) { flag = true; break; } } if (flag) { canStop = true; continue; } if (var.size() &lt;= curMaxLoop) { if (loop.empty()) loop.push(0); if (a == &quot;n&quot; &amp;&amp; b == &quot;n&quot; || a != &quot;n&quot; &amp;&amp; b != &quot;n&quot; &amp;&amp; s2i(a) &lt;= s2i(b)) // 时间复杂度次数不变 loop.push(loop.top()); else if (a == &quot;n&quot; || a != &quot;n&quot; &amp;&amp; b != &quot;n&quot; &amp;&amp; s2i(a) &gt; s2i(b)) // 该层循环无法进入 curMaxLoop = var.size(); else // 时间复杂度次数+1 loop.push(loop.top() + 1); } maxO = max(maxO, loop.top()); var.push_back(x); } } if (!var.empty()) // 终止符号少了 canStop = true; if (canStop) { cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; continue; } if (maxO == c) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; } return 0;}","link":"/2022/08/07/%E6%B4%9B%E8%B0%B7P3952/"},{"title":"洛谷P1908 逆序对","text":"又是利用了归并排序 难度：普及/提高- 题面 题目描述猫猫 TOM 和小老鼠 JERRY 最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。 最近，TOM 老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中 $a_i&gt;a_j$ 且 $i&lt;j$ 的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。注意序列中可能有重复数字。 输入格式第一行，一个数 $n$，表示序列中有 $n$个数。 第二行 $n$ 个数，表示给定的序列。序列中每个数字不超过 $10^9$。 输出格式输出序列中逆序对的数目。 样例样例输入12&gt;65 4 2 6 3 1 样例输出1&gt;11 提示对于 $25%$ 的数据，$n \\leq 2500$ 对于 $50%$ 的数据，$n \\leq 4 \\times 10^4$。 对于所有数据，$n \\leq 5 \\times 10^5$ 解法朴素解法遍历所有的情况，共$\\frac{n(n-1)}{2}$种，时间复杂度$O(n^2)$，只能过$25%$的点。 主要代码 123456789101112131415int countInversion(int nums[], int size){ int ans = 0; for (int i = 0; i &lt; size; ++i) { for (int j = i + 1; j &lt; size; ++j) { if (nums[i] &gt; nums[j]) { ++ans; } } } return ans;} 冒泡排序实现冒泡排序，但是在每一次发生交换时记录一次。这种做法的正确性在于交换相邻的逆序对不会影响其他的逆序对的计数。其时间复杂度与朴素解法相同，但由于交换元素会消耗更多的时间，因此在一般情况下实际上比朴素解法更慢。 改进后的冒泡算法，即发现序列有序后停止算法会在序列基本有序的情况下优化时间复杂度。 插入排序序列中每一个元素都与其前序列中比自己大的数构成逆序对。因此插入排序中每一次比较都代表一个逆序对。由于每次比较都只找比自己大的元素，因此时间性能由于前两者，但时间复杂度仍然为$O(n^2)$。 代码： 1234567891011121314151617int countInversion(int nums[], int size){ int ans = 0; for (int i = 1; i &lt; size; ++i) { int key = nums[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt; key) { nums[j + 1] = nums[j]; ++ans; --j; } nums[j + 1] = key; } return ans;} 归并排序与冒泡排序的想法类似，一个归并段内的元素顺序的变换不会影响到序列其他部分的逆序对的数量。 在要进行归并的两个归并段中，后一个段第一个待归并元素在归并时，一定可以与前一个归并段的所有元素组成逆序对。因此只需要在当后半归并段待排序元素小于前半段待排序元素时，在结果中加上前半归并段未排序元素的数量就能得到结果。 特别要注意的是，判断指针移动的条件一定是前大于等于后，否则就会出现漏数的情况。 代码： 123456789101112131415161718192021222324252627282930313233int rCountInversion(int nums[], int left, int right){ if (left &gt;= right) return 0; int count = 0; int mid = (left + right) / 2; count += rCountInversion(nums, left, mid); count += rCountInversion(nums, mid + 1, right); int *newNums = new int[right - left + 1]; int it = left, iu = mid + 1, i = 0; while (it &lt;= mid &amp;&amp; iu &lt;= right) { if (nums[it] &gt; nums[iu]) { count += (mid - it + 1); } newNums[i++] = (nums[it] &lt;= nums[iu] ? nums[it++] : nums[iu++]); } while (it &lt;= mid) { newNums[i++] = nums[it++]; } while (iu &lt;= right) { newNums[i++] = nums[iu++]; } for (int i = 0; i &lt;= right - left; ++i) { nums[left + i] = newNums[i]; } return count;}","link":"/2022/08/12/%E6%B4%9B%E8%B0%B7P1908/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"洛谷刷题","slug":"洛谷刷题","link":"/categories/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98/"}],"pages":[]}